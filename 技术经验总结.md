
# Workflow

## Workflow: Prompt chaining

提示链将任务分解为一系列步骤，其中每个 LLM 调用都会处理前一个步骤的输出。
何时使用此工作流程：此工作流程非常适合任务可以轻松清晰地分解为固定子任务的情况。
主要目标：通过简化每次 LLM 调用，以降低延迟并提高准确率。
例子：

## Workflow: Routing

路由会对输入进行分类，并将其定向到专门的后续任务。此工作流程允许分离关注点，并构建更专业的提示。如果没有此工作流程，针对一种输入进行优化可能会损害其他输入的性能。
何时使用此工作流程：路由非常适合复杂任务，其中存在不同的类别，最好分别处理，并且可以通过 LLM 或更传统的分类模型/算法准确处理分类。
例子：
 - 将不同类型的客户服务查询（一般问题、退款请求、技术支持）引导到不同的下游流程、提示和工具中。

## Workflow: Parallelization

LLM 有时可以同时处理一项任务，并以编程方式聚合其输出。这种工作流程（并行化）体现在两个关键变化中：
    分段：将任务分解为并行运行的独立子任务。
    投票：多次运行相同的任务以获得不同的输出。
何时使用此工作流程：当拆分后的子任务可以并行化以提高速度，或者需要多个视角或尝试以获得更高置信度的结果时，并行化非常有效。对于涉及多个考量的复杂任务，当每个考量都由单独的 LLM 调用处理时，LLM 通常表现更好，从而能够专注于每个特定方面。
例子：
 - 切片：实现防护机制，其中一个模型实例处理用户查询，而另一个模型实例则筛选不适当的内容或请求。这通常比使用同一个 LLM 调用同时处理防护机制和核心响应效果更好。自动评估 LLM 性能，其中每次 LLM 调用都会评估模型在给定提示上性能的不同方面
 - 投票

## Workflow: Orchestrator-workers

在协调器-工作者工作流中，中央 LLM 动态分解任务，将其委托给工作者 LLM，并综合其结果。
何时使用此工作流程：此工作流程非常适合无法预测所需子任务的复杂任务（例如，在编码过程中，需要更改的文件数量以及每个文件的更改性质可能取决于任务本身）。虽然它在拓扑结构上与并行化类似，但其与并行化的关键区别在于灵活性——子任务并非预先定义，而是由编排器根据具体输入确定。
例子：
 - 每次对多个文件进行复杂更改的编码产品。
 - 搜索任务涉及从多个来源收集和分析信息以获取可能相关的信息。

## Workflow: Evaluator-optimizer

在评估器-优化器工作流中，一个 LLM 调用生成响应，而另一个调用在循环中提供评估和反馈。
何时使用此工作流程：当我们拥有清晰的评估标准，并且迭代改进能够提供可衡量的价值时，此工作流程尤其有效。良好契合的两个标志是：首先，当人类清晰地表达反馈时，LLM 的答案可以得到显著的改进；其次，LLM 能够提供这样的反馈。这类似于人类作家在撰写一篇精良文档时可能经历的迭代写作过程。
示例：
 - 文学翻译中存在一些细微差别，翻译人员（法学硕士）最初可能无法捕捉到，但评估人员（法学硕士）可以提供有用的批评。
 - 复杂的搜索任务需要多轮搜索和分析才能收集全面的信息，评估人员将决定是否需要进一步搜索。

 # GitLab

问题一：

格式：git clone http://{username}:{token}@{URL}
参考：https://blog.csdn.net/u010773514/article/details/131186708


**配置ssh**

https://blog.csdn.net/weixin_42310154/article/details/118340458

**拉取代码**

git clone ....

**拉取远程分支至本地**

1)在正式拉取代码前，先设置好自己的用户名和邮箱(username设置为你自己的用户名，email设置为你自己的邮箱).

git config --global user.name "username"

git config --global user.email "email"

2)切换至本地文件，初始化git。

   git init

3)与远程项目建立连接。

   git  remote add origin gitprojectaddress（gitprojectaddress是你的git项目ssh的地址）

4)git clone 指定分支。

git clone -b dev_jk http://10.1.1.11/service/tmall-service.git

**查看当前状态：** git status

**提交代码到本地git缓存区：** git add .  /  git add 文件名称

**推送代码到本地git库：** git commit (文件名) -m "提交代码备注"

**提交本地代码到远程仓库：** git push <远程主机名> <远程分支名>

拉取远端更新的代码：git pull



## visual studio code快捷键

隐藏和查看侧边栏：Command+B

隐藏和查看终端：Command+J

打开命令面板：Command+P

整行复制：光标放代码行按住 Command+V

光标处折叠代码：按住Command，K 之后 [

代码行移动： option + ⬆️

## mineru

1 **配置**

包、权重、软件、路径

```
pip install magic-pdf  （最新版）

pip install huggingface_hub
wget https://github.com/opendatalab/MinerU/raw/master/scripts/download_models_hf.py -O download_models_hf.py
python download_models_hf.py

sudo apt-get install libreoffice
```

找到/root/magic-pdf.json，然后查看其中权重路径`models-dir`、`layoutreader-model-dir`

可以考虑迁移权重位置、magic-pdf.json

export MINERU_TOOLS_CONFIG_JSON=/home/coder/lqq/ParaContract/contract_process/magic-pdf.json

2 **使用**

https://mineru.readthedocs.io/en/latest/user_guide/quick_start/convert_pdf.html

## ContextGem（x）


https://github.com/shcherbak-ai/contextgem?tab=readme-ov-file

# Linux命令

**进程抓取**：ps aux | grep vllm

**装包**：pip install `peft `  -i https://pypi.corp.kuaiasdasdasdashou.com/kuaiasdasdasdashou/prod/+simple/

**复制文件夹**： cp -r 源文件夹路径 目标文件夹路径

**删除**：rm -rf output/

**GPU释放显存**：sudo fuser /dev/nvidia*

**文件移动命令**：

![image](assets/image-20250527180514-9eukuev.png)

**查看指定文件大小**：du -sh *

**后台运行**：`nohup python your_script.py > output.log 2>&1 &`

生成一个干净的 requirements：pip freeze | grep -vE "^-e |@ file://" > requirements.txt

**ks服务器装包**：sudo -E apt-get install libxml2（**使用**  **`-E`** **后**，`sudo` 会继承当前用户的完整环境变量）

**查看磁盘剩余空间**: df -hl

**查看当前目录的大小**: du -sh

**安装flash-attn**：MAX_JOBS=4 pip install flash-attn==`2.8.0.post2` --no-build-isolation -i xxxx

```python
nvcc==12.4
gcc (Debian 12.2.0-14) ==12.2.0
torch==2.4.0
transformers==4.46.0
flash-attn==2.8.0.post2

torch==2.6.0
transformers==4.46.0
flash-attn==2.6.3
flash-attn==2.7.4.post1

MAX_JOBS=4 pip install flash-attn==2.7.4.post1 --no-build-isolation
```

**安装libxml2插件**：apt-get install libxml2

# pandas命令

xxx = pd.read_csv()

**读取数据：**

pd.read_csv('data.csv')：读取csv

pd.read_excel('data.xlsx')：读取excel

**查看数据：**

`xxx.head(n=20)`：显示前 n 行数据

`xxx.tail(n=20)`：显示后 n 行数据

xxx.info()：显示数据的信息，包括列名、数据类型、缺失值等；

`xxx.describe()`显示数据的信息，包括列名、数据类型、缺失值等；

`xxx.shape()`：显示数据的行数和列数。

`xxx.isnull().sum()`：空数据检查

df.pivot_table(values, index, columns, aggfunc)：生成透视表

**数据选择和切片**

df[column_name]：选择指定的列

df.loc[row_index, column_name]：通过标签选择数据；

df.iloc[row_index, column_index]：通过位置选择数据

df.filter(items=[column_name1, column_name2])：选择指定的列

pd.concat([df1, df2])：将多个数据框按照行或列进行合并；

pd.merge(df1, df2, on=column_name)：按照指定列将两个数据框进行合并

**数据排序**

df.sort_values(column_name)：按照指定列的值排序

df.sort_values([column_name1, column_name2], ascending=[True, False])：按照多个列的值排序；

df.sort_index()：按照索引排序